<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (mirage-channel.Mirage_channel.S)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">mirage-channel</a> &#x00BB; <a href="../index.html">Mirage_channel</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>Mirage_channel.S</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span></code></div><div class="spec-doc"><p>The type for errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_error" class="anchored"><a href="#val-pp_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_error : <span><a href="#type-error">error</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pp_error</code> is the pretty-printer for errors.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-write_error#row" class="anchored"><a href="#type-write_error#row" class="anchor"></a><code><span><span class="keyword">type</span> write_error#row</span></code></div><div class="spec-doc"><p>The type for write errors.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-write_error" class="anchored"><a href="#type-write_error" class="anchor"></a><code><span><span class="keyword">and</span> write_error</span><span> = <span class="keyword">private</span> </span><span>[&gt; </span></code><table><tr id="type-write_error.Mirage_flow.write_error" class="anchored"><td class="def type"><a href="#type-write_error.Mirage_flow.write_error" class="anchor"></a><code><span>| </span></code><code><span><span class="xref-unresolved">Mirage_flow</span>.write_error</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for write errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_write_error" class="anchored"><a href="#val-pp_write_error" class="anchor"></a><code><span><span class="keyword">val</span> pp_write_error : <span><a href="#type-write_error">write_error</a> <span class="xref-unresolved">Fmt</span>.t</span></span></code></div><div class="spec-doc"><p><code>pp_write_error</code> is the pretty-printer for write errors.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-flow" class="anchored"><a href="#type-flow" class="anchor"></a><code><span><span class="keyword">type</span> flow</span></code></div><div class="spec-doc"><p>The type for unbuffered network flow.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type for the state associated with channels, such as the inflight buffers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create" class="anchored"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span><a href="#type-flow">flow</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create flow</code> allocates send and receive buffers and associates them with the given unbuffered <code>flow</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-to_flow" class="anchored"><a href="#val-to_flow" class="anchor"></a><code><span><span class="keyword">val</span> to_flow : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-flow">flow</a></span></code></div><div class="spec-doc"><p><code>to_flow t</code> returns the flow that backs this channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_char" class="anchored"><a href="#val-read_char" class="anchor"></a><code><span><span class="keyword">val</span> read_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span>char <span class="xref-unresolved">Mirage_flow</span>.or_eof</span>, <a href="#type-error">error</a> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Reads a single character from the channel, blocking if there is no immediately available input data.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_some" class="anchored"><a href="#val-read_some" class="anchor"></a><code><span><span class="keyword">val</span> read_some : 
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span><span class="xref-unresolved">Cstruct</span>.t <span class="xref-unresolved">Mirage_flow</span>.or_eof</span>, <a href="#type-error">error</a> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_some ?len t</code> reads up to <code>len</code> characters from the input channel and at most a full <code>buffer</code>. If <code>len</code> is not specified, it reads all available data and returns that buffer.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_exactly" class="anchored"><a href="#val-read_exactly" class="anchor"></a><code><span><span class="keyword">val</span> read_exactly : 
  <span>len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="xref-unresolved">Mirage_flow</span>.or_eof</span>, <a href="#type-error">error</a> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_exactly len t</code> reads <code>len</code> bytes from the channel <code>t</code> or fails with <code>Eof</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_line" class="anchored"><a href="#val-read_line" class="anchor"></a><code><span><span class="keyword">val</span> read_line : 
  <span>?len:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span><span><span class="xref-unresolved">Cstruct</span>.t list</span> <span class="xref-unresolved">Mirage_flow</span>.or_eof</span>, <a href="#type-error">error</a> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>read_line t</code> reads a line of input, which is terminated either by a CRLF sequence, or the end of the channel (which counts as a line).</p><p>If <code>?len</code> is provided then the maximum length of the line returned will be <code>len</code> bytes. If the line is longer than <code>len</code> then an error will be returned. With <code>len = 0</code>, <code>read_line</code> always returns an error.</p><p>If the input data is untrusted then care should be taken to ensure <code>len</code> is set to an application-specific small value to bound the amount of memory allocated by <code>read_line</code>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>Returns a list of views that terminates at EOF.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-write_char" class="anchored"><a href="#val-write_char" class="anchor"></a><code><span><span class="keyword">val</span> write_char : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>char <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_char t ch</code> writes a single character to the output channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_string" class="anchored"><a href="#val-write_string" class="anchor"></a><code><span><span class="keyword">val</span> write_string : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_string t buf off len</code> writes <code>len</code> bytes from a string <code>buf</code>, starting from from offset <code>off</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_buffer" class="anchored"><a href="#val-write_buffer" class="anchor"></a><code><span><span class="keyword">val</span> write_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_buffer t buf</code> copies the buffer to the channel's output buffer. The buffer should not be modified after being written, and it will be recycled into the buffer allocation pool at some future point.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-write_line" class="anchored"><a href="#val-write_line" class="anchor"></a><code><span><span class="keyword">val</span> write_line : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write_line t buf</code> writes the string <code>buf</code> to the output channel and append a newline character afterwards.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-flush" class="anchored"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( unit, <a href="#type-write_error">write_error</a> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>flush t</code> flushes the output buffer and block if necessary until it is all written out to the flow.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( unit, <a href="#type-write_error">write_error</a> )</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>close t</code> calls <a href="#val-flush"><code>flush</code></a> and then close the underlying flow.</p></div></div></div></body></html>